from __future__ import annotations

import os
import re
from datetime import datetime
from io import BytesIO
from typing import Any, Sequence

from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.lib.utils import ImageReader
from reportlab.pdfgen import canvas
from reportlab.platypus import (
    Flowable,
    LongTable,
    SimpleDocTemplate,
    Spacer,
    TableStyle,
)

LEFT_MARGIN = 14 * mm
RIGHT_MARGIN = 14 * mm
TOP_MARGIN = 14 * mm
BOTTOM_MARGIN = 16 * mm
PAGE_WIDTH, PAGE_HEIGHT = A4
CONTENT_WIDTH = PAGE_WIDTH - LEFT_MARGIN - RIGHT_MARGIN

HEADER_TOP_MARGIN = 36.0
HEADER_HEIGHT = 80.0
HEADER_LEFT_PADDING = 42.0
HEADER_RIGHT_PADDING = 42.0
HEADER_LOGO_SIZE = 38.0
HEADER_TEXT_GAP = 14.0
HEADER_AFTER_GAP = 12.0
HEADER_TITLE_FONT_SIZE = 22.0
HEADER_SUBTITLE_FONT_SIZE = 11.0

KPI_GAP_X = 10.0
KPI_GAP_Y = 11.0
KPI_GAP_AFTER = 16.0
KPI_CARD_HEIGHT = 64.0
KPI_CARD_RADIUS = 7.0
KPI_CARD_PAD_X = 10.0
KPI_CARD_PAD_Y = 10.0
KPI_VALUE_FONT_SIZE = 12
KPI_LABEL_FONT_SIZE = 8
PDF_LOGO_PATH = os.path.join(os.path.dirname(__file__), "assets", "logo.png")

PALETTE = {
    "navy": colors.HexColor("#0F172A"),
    "text": colors.HexColor("#0F172A"),
    "muted": colors.HexColor("#64748B"),
    "line": colors.HexColor("#D1D5DB"),
    "card_fill": colors.HexColor("#F8FAFC"),
    "card_stroke": colors.HexColor("#CBD5E1"),
    "stripe_even": colors.HexColor("#F8FAFC"),
    "stripe_odd": colors.HexColor("#F1F5F9"),
    "grid": colors.HexColor("#E2E8F0"),
}


def render_kpi_row(
    canv: canvas.Canvas,
    x0: float,
    y: float,
    cards: Sequence[dict[str, str]],
    cols: int,
    gap: float,
    card_h: float,
) -> None:
    if cols <= 0:
        return

    card_w = (CONTENT_WIDTH - (gap * (cols - 1))) / cols
    draw_count = min(len(cards), cols)

    for index in range(draw_count):
        x = x0 + (index * (card_w + gap))
        card = cards[index]
        value = _safe_text(card.get("value"), fallback="N/A")
        label = _safe_text(card.get("label"), fallback="-")

        canv.setFillColor(PALETTE["card_fill"])
        canv.setStrokeColor(PALETTE["card_stroke"])
        canv.setLineWidth(0.8)
        canv.roundRect(x, y, card_w, card_h, KPI_CARD_RADIUS, stroke=1, fill=1)

        value_x = x + KPI_CARD_PAD_X
        value_y = y + card_h - KPI_CARD_PAD_Y - KPI_VALUE_FONT_SIZE
        label_x = x + KPI_CARD_PAD_X
        label_y = y + KPI_CARD_PAD_Y

        canv.setFillColor(PALETTE["text"])
        canv.setFont("Helvetica-Bold", KPI_VALUE_FONT_SIZE)
        canv.drawString(value_x, value_y, value)

        canv.setFillColor(PALETTE["muted"])
        canv.setFont("Helvetica", KPI_LABEL_FONT_SIZE)
        canv.drawString(label_x, label_y, label)


class KpiRow(Flowable):
    def __init__(self, *, cards: Sequence[dict[str, str]], cols: int, gap: float, card_h: float) -> None:
        super().__init__()
        self.cards = list(cards)
        self.cols = cols
        self.gap = gap
        self.card_h = card_h
        self.width = CONTENT_WIDTH
        self.height = card_h

    def wrap(self, avail_width: float, avail_height: float) -> tuple[float, float]:
        return self.width, self.height

    def draw(self) -> None:
        self.canv.saveState()
        render_kpi_row(
            canv=self.canv,
            x0=0.0,
            y=0.0,
            cards=self.cards,
            cols=self.cols,
            gap=self.gap,
            card_h=self.card_h,
        )
        self.canv.restoreState()


class NumberedCanvas(canvas.Canvas):
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self._saved_page_states: list[dict[str, Any]] = []

    def showPage(self) -> None:
        self._saved_page_states.append(dict(self.__dict__))
        self._startPage()

    def save(self) -> None:
        total_pages = len(self._saved_page_states)
        for state in self._saved_page_states:
            self.__dict__.update(state)
            self._draw_footer(total_pages)
            canvas.Canvas.showPage(self)
        canvas.Canvas.save(self)

    def _draw_footer(self, total_pages: int) -> None:
        line_y = 11 * mm
        text_y = 7.6 * mm

        self.saveState()
        self.setStrokeColor(PALETTE["line"])
        self.setLineWidth(0.5)
        self.line(LEFT_MARGIN, line_y, PAGE_WIDTH - RIGHT_MARGIN, line_y)

        self.setFillColor(PALETTE["muted"])
        self.setFont("Helvetica", 8)
        self.drawString(LEFT_MARGIN, text_y, "Generated by Oilchem Attendance Admin")
        self.drawRightString(
            PAGE_WIDTH - RIGHT_MARGIN,
            text_y,
            f"Page {self._pageNumber} of {total_pages}",
        )
        self.restoreState()


def resolve_logo_path() -> str | None:
    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
    candidates = [
        os.path.join(project_root, "backend", "static", "oilchem_logo.png"),
        os.path.join(project_root, "frontend", "public", "oilchem_logo.png"),
        os.path.join(project_root, "frontend", "public", "logo.png"),
        os.path.join(project_root, "frontend", "public", "Logo(white).png"),
        PDF_LOGO_PATH,
    ]

    for candidate in candidates:
        if os.path.exists(candidate):
            return candidate
    return None


def _fit_text(canv: canvas.Canvas, text: str, *, font_name: str, font_size: float, max_width: float) -> str:
    if max_width <= 0:
        return ""

    cleaned = _safe_text(text, fallback="")
    if not cleaned:
        return ""

    if canv.stringWidth(cleaned, font_name, font_size) <= max_width:
        return cleaned

    suffix = "..."
    clipped = cleaned
    while clipped and canv.stringWidth(clipped + suffix, font_name, font_size) > max_width:
        clipped = clipped[:-1]
    return (clipped + suffix) if clipped else suffix


def _draw_logo_in_square(canv: canvas.Canvas, *, logo_path: str | None, x: float, y: float, size: float) -> None:
    canv.saveState()
    canv.setFillColor(colors.HexColor("#EEF3FA"))
    canv.roundRect(x - 4, y - 4, size + 8, size + 8, 6, stroke=0, fill=1)

    if logo_path and os.path.exists(logo_path):
        try:
            reader = ImageReader(logo_path)
            image_width, image_height = reader.getSize()
            if image_width > 0 and image_height > 0:
                scale = min(size / float(image_width), size / float(image_height))
                draw_w = float(image_width) * scale
                draw_h = float(image_height) * scale
                draw_x = x + ((size - draw_w) / 2.0)
                draw_y = y + ((size - draw_h) / 2.0)
                canv.drawImage(
                    reader,
                    draw_x,
                    draw_y,
                    width=draw_w,
                    height=draw_h,
                    preserveAspectRatio=False,
                    mask="auto",
                )
        except Exception:
            pass
    canv.restoreState()


def draw_header(
    c: canvas.Canvas,
    page_width: float,
    page_height: float,
    title: str,
    subtitle_lines: list[str],
    logo_path: str | None,
) -> None:
    top_margin = HEADER_TOP_MARGIN
    header_h = HEADER_HEIGHT
    left_pad = HEADER_LEFT_PADDING
    right_pad = HEADER_RIGHT_PADDING
    logo_box = HEADER_LOGO_SIZE

    header_top = page_height - top_margin
    header_bottom = header_top - header_h
    mid_y = header_bottom + (header_h / 2.0)

    logo_x = left_pad
    logo_y = mid_y - (logo_box / 2.0)
    reserved_left = logo_x + logo_box + 16.0

    c.saveState()
    _draw_logo_in_square(c, logo_path=logo_path, x=logo_x, y=logo_y, size=logo_box)

    title_font = "Helvetica-Bold"
    title_size = HEADER_TITLE_FONT_SIZE
    title_text = _safe_text(title, fallback="Oilchem Attendance Report")

    title_width = c.stringWidth(title_text, title_font, title_size)
    title_x = (page_width - title_width) / 2.0

    if title_x < reserved_left:
        title_size = 20.0
        title_width = c.stringWidth(title_text, title_font, title_size)
        title_x = (page_width - title_width) / 2.0
        if title_x < reserved_left:
            title_x = reserved_left
            max_title_width = max((page_width - right_pad) - title_x, 0.0)
            title_text = _fit_text(
                c,
                title_text,
                font_name=title_font,
                font_size=title_size,
                max_width=max_title_width,
            )
            title_width = c.stringWidth(title_text, title_font, title_size)

    title_baseline_y = mid_y + (title_size * 0.35)
    c.setFillColor(PALETTE["text"])
    c.setFont(title_font, title_size)
    c.drawString(title_x, title_baseline_y, title_text)

    subtitle_font = "Helvetica"
    subtitle_size = HEADER_SUBTITLE_FONT_SIZE
    subtitle_leading = 14.0
    subtitle_y = title_baseline_y - (title_size * 0.95)

    c.setFillColor(PALETTE["muted"])
    c.setFont(subtitle_font, subtitle_size)
    for line in subtitle_lines[:2]:
        subtitle_text = _safe_text(line, fallback="")
        subtitle_width = c.stringWidth(subtitle_text, subtitle_font, subtitle_size)
        subtitle_x = (page_width - subtitle_width) / 2.0
        if subtitle_x < reserved_left:
            subtitle_x = reserved_left
            max_subtitle_width = max((page_width - right_pad) - subtitle_x, 0.0)
            subtitle_text = _fit_text(
                c,
                subtitle_text,
                font_name=subtitle_font,
                font_size=subtitle_size,
                max_width=max_subtitle_width,
            )
        c.drawString(subtitle_x, subtitle_y, subtitle_text)
        subtitle_y -= subtitle_leading

    divider_y = header_bottom
    c.setStrokeColor(PALETTE["line"])
    c.setLineWidth(0.6)
    c.line(left_pad, divider_y, page_width - right_pad, divider_y)
    c.restoreState()


def _safe_text(value: Any, *, fallback: str = "-") -> str:
    if value is None:
        return fallback
    text = str(value).strip()
    return text if text else fallback


def _parse_timestamp(value: Any) -> datetime | None:
    if value is None:
        return None
    if isinstance(value, datetime):
        return value

    text = str(value).strip()
    if not text:
        return None

    formats = (
        "%Y-%m-%d %H:%M:%S",
        "%Y-%m-%d %H:%M:%S.%f",
        "%Y-%m-%dT%H:%M:%S",
        "%Y-%m-%dT%H:%M:%S.%f",
        "%Y-%m-%d %H:%M",
        "%Y-%m-%dT%H:%M",
    )

    for pattern in formats:
        try:
            return datetime.strptime(text, pattern)
        except ValueError:
            continue
    return None


def format_dt_12h(value: Any) -> str:
    timestamp = _parse_timestamp(value)
    if not timestamp:
        return _safe_text(value)
    return timestamp.strftime("%Y-%m-%d %I:%M:%S %p")


def format_duration_readable(minutes: int | None) -> str:
    if minutes is None or minutes < 0:
        return "N/A"
    hours = minutes // 60
    mins = minutes % 60
    return f"{hours} Hrs {mins:02d} Mins"


def _to_int(value: Any) -> int | None:
    if value is None:
        return None
    if isinstance(value, bool):
        return None
    if isinstance(value, int):
        return value
    text = str(value).strip()
    if not text:
        return None
    try:
        return int(text)
    except ValueError:
        return None


def _minutes_to_hhmm(minutes: int | None) -> str | None:
    if minutes is None or minutes < 0:
        return None
    hours = minutes // 60
    mins = minutes % 60
    return f"{hours:02d}:{mins:02d}"


def _hhmm_to_minutes(value: Any) -> int | None:
    text = _safe_text(value, fallback="")
    if not text:
        return None

    match = re.match(r"^(\d+):(\d{2})$", text)
    if not match:
        return None

    try:
        hours = int(match.group(1))
        mins = int(match.group(2))
    except ValueError:
        return None
    return (hours * 60) + mins


def _has_value(value: Any) -> bool:
    if value is None:
        return False
    if isinstance(value, str):
        cleaned = value.strip()
        return bool(cleaned and cleaned != "-")
    return True


def _normalize_daily_row(report: dict[str, Any]) -> dict[str, Any]:
    minutes = _to_int(report.get("duration_minutes"))
    duration_hhmm = _safe_text(report.get("duration_hhmm"), fallback="")
    if not duration_hhmm and minutes is not None:
        duration_hhmm = _safe_text(_minutes_to_hhmm(minutes), fallback="")

    return {
        "date": _safe_text(report.get("date")),
        "first_in": report.get("first_in"),
        "last_out": report.get("last_out"),
        "duration_hhmm": duration_hhmm,
        "duration_minutes": minutes,
    }


def _normalize_monthly_rows(report: dict[str, Any]) -> list[dict[str, Any]]:
    rows: list[dict[str, Any]] = []
    for item in report.get("records", []):
        minutes = _to_int(item.get("duration_minutes"))
        duration_hhmm = _safe_text(item.get("duration_hhmm"), fallback="")
        if not duration_hhmm and minutes is not None:
            duration_hhmm = _safe_text(_minutes_to_hhmm(minutes), fallback="")

        rows.append(
            {
                "date": _safe_text(item.get("date")),
                "first_in": item.get("first_in"),
                "last_out": item.get("last_out"),
                "duration_hhmm": duration_hhmm,
                "duration_minutes": minutes,
            }
        )
    return rows


def _normalize_yearly_rows(report: dict[str, Any]) -> list[dict[str, Any]]:
    rows: list[dict[str, Any]] = []
    for item in report.get("months", []):
        minutes = _to_int(item.get("total_minutes"))
        duration_hhmm = _safe_text(item.get("total_duration_hhmm"), fallback="")
        if not duration_hhmm and minutes is not None:
            duration_hhmm = _safe_text(_minutes_to_hhmm(minutes), fallback="")

        rows.append(
            {
                "date": _safe_text(item.get("month")),
                "first_in": None,
                "last_out": None,
                "duration_hhmm": duration_hhmm,
                "duration_minutes": minutes,
            }
        )
    return rows


def _table_rows_from_normalized(rows: Sequence[dict[str, Any]]) -> list[list[str]]:
    rendered_rows: list[list[str]] = []
    for row in rows:
        rendered_rows.append(
            [
                _safe_text(row.get("date")),
                format_dt_12h(row.get("first_in")) if _has_value(row.get("first_in")) else "-",
                format_dt_12h(row.get("last_out")) if _has_value(row.get("last_out")) else "-",
                _safe_text(row.get("duration_hhmm")),
            ]
        )
    return rendered_rows


def _derive_summary_metrics(
    *,
    report: dict[str, Any],
    rows: Sequence[dict[str, Any]],
) -> dict[str, Any]:
    working_days = 0
    total_minutes = 0
    missing_punch_days = 0
    dates: list[str] = []

    for row in rows:
        row_date = _safe_text(row.get("date"), fallback="")
        if row_date:
            dates.append(row_date)

        first_present = _has_value(row.get("first_in"))
        last_present = _has_value(row.get("last_out"))

        minutes = _to_int(row.get("duration_minutes"))
        if minutes is None:
            minutes = _hhmm_to_minutes(row.get("duration_hhmm"))

        if first_present and last_present and minutes is not None:
            working_days += 1
            total_minutes += minutes
        elif first_present != last_present:
            missing_punch_days += 1

    summary_working_days = _to_int(report.get("total_days"))
    if summary_working_days is None:
        summary_working_days = _to_int(report.get("total_worked_days"))

    summary_total_minutes = _to_int(report.get("total_minutes"))

    if working_days == 0 and summary_working_days is not None:
        working_days = max(summary_working_days, 0)

    if total_minutes == 0 and summary_total_minutes is not None:
        total_minutes = max(summary_total_minutes, 0)

    average_minutes = int(total_minutes / working_days) if working_days > 0 else 0

    first_day = min(dates) if dates else "N/A"
    last_day = max(dates) if dates else "N/A"

    return {
        "working_days": working_days,
        "total_minutes": total_minutes,
        "average_minutes": average_minutes,
        "missing_punch_days": missing_punch_days,
        "first_day": first_day,
        "last_day": last_day,
        "total_records": len(rows),
    }


def _resolve_total_in_out_hhmm(report: dict[str, Any]) -> tuple[str, str]:
    total_in_hhmm = _safe_text(report.get("totalInHHMM"), fallback="")
    total_out_hhmm = _safe_text(report.get("totalOutHHMM"), fallback="")

    if not total_in_hhmm:
        in_minutes = _to_int(report.get("totalInMinutes"))
        total_in_hhmm = _safe_text(_minutes_to_hhmm(in_minutes), fallback="N/A")

    if not total_out_hhmm:
        out_minutes = _to_int(report.get("totalOutMinutes"))
        total_out_hhmm = _safe_text(_minutes_to_hhmm(out_minutes), fallback="N/A")

    return total_in_hhmm, total_out_hhmm


def _build_attendance_table(
    rows: Sequence[list[str]],
    *,
    available_width: float,
    total_in_hhmm: str,
    total_out_hhmm: str,
) -> LongTable:
    headers = ["Date", "First IN", "Last OUT", "Duration (HH:MM)"]
    table_data: list[list[str]] = [headers]

    if rows:
        table_data.extend(rows)
    else:
        table_data.append(["No data", "", "", ""])

    table_data.append(["Total In Hour", "", "", _safe_text(total_in_hhmm, fallback="N/A")])
    table_data.append(["Total Out Hour", "", "", _safe_text(total_out_hhmm, fallback="N/A")])
    total_row_start = len(table_data) - 2

    col_widths = [
        available_width * 0.21,
        available_width * 0.31,
        available_width * 0.31,
        available_width * 0.17,
    ]

    table = LongTable(table_data, colWidths=col_widths, repeatRows=1, hAlign="LEFT")

    style_commands: list[tuple[Any, ...]] = [
        ("BACKGROUND", (0, 0), (-1, 0), PALETTE["navy"]),
        ("TEXTCOLOR", (0, 0), (-1, 0), colors.white),
        ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
        ("FONTSIZE", (0, 0), (-1, 0), 9),
        ("ALIGN", (0, 0), (-1, 0), "LEFT"),
        ("FONTNAME", (0, 1), (-1, -1), "Helvetica"),
        ("FONTSIZE", (0, 1), (-1, -1), 8.6),
        ("TEXTCOLOR", (0, 1), (-1, -1), PALETTE["text"]),
        ("GRID", (0, 0), (-1, -1), 0.4, PALETTE["grid"]),
        ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
        ("LEFTPADDING", (0, 0), (-1, -1), 6),
        ("RIGHTPADDING", (0, 0), (-1, -1), 6),
        ("TOPPADDING", (0, 0), (-1, -1), 4),
        ("BOTTOMPADDING", (0, 0), (-1, -1), 4),
    ]

    for row_index in range(1, len(table_data)):
        background = PALETTE["stripe_even"] if row_index % 2 else PALETTE["stripe_odd"]
        style_commands.append(("BACKGROUND", (0, row_index), (-1, row_index), background))

    for row_index in range(total_row_start, len(table_data)):
        style_commands.extend(
            [
                ("BACKGROUND", (0, row_index), (-1, row_index), colors.HexColor("#E5ECF5")),
                ("FONTNAME", (0, row_index), (-1, row_index), "Helvetica-Bold"),
                ("TEXTCOLOR", (0, row_index), (-1, row_index), PALETTE["navy"]),
                ("SPAN", (0, row_index), (2, row_index)),
                ("ALIGN", (0, row_index), (2, row_index), "LEFT"),
                ("ALIGN", (3, row_index), (3, row_index), "LEFT"),
            ]
        )

    table.setStyle(TableStyle(style_commands))
    return table


def _build_pdf_document(
    *,
    period_label: str,
    employee_name: str,
    card_no: str,
    normalized_rows: Sequence[dict[str, Any]],
    summary_metrics: dict[str, Any],
    total_in_hhmm: str,
    total_out_hhmm: str,
) -> bytes:
    buffer = BytesIO()
    generated_at = datetime.now().strftime("%Y-%m-%d %I:%M %p")
    logo_path = resolve_logo_path()

    subtitle_lines = [
        f"Employee: {_safe_text(employee_name, fallback='Unknown')} | CardNo: {_safe_text(card_no, fallback='Unknown')}",
        f"Period: {_safe_text(period_label, fallback='N/A')} | Generated: {generated_at}",
    ]

    def _draw_page_header(canv: canvas.Canvas, doc: SimpleDocTemplate) -> None:
        draw_header(
            canv,
            page_width=doc.pagesize[0],
            page_height=doc.pagesize[1],
            title="Oilchem Attendance Report",
            subtitle_lines=subtitle_lines,
            logo_path=logo_path,
        )

    doc = SimpleDocTemplate(
        buffer,
        pagesize=A4,
        leftMargin=LEFT_MARGIN,
        rightMargin=RIGHT_MARGIN,
        topMargin=HEADER_TOP_MARGIN + HEADER_HEIGHT + HEADER_AFTER_GAP,
        bottomMargin=BOTTOM_MARGIN,
    )

    available_width = CONTENT_WIDTH

    story: list[Any] = []

    top_kpis = [
        {"label": "Working Days", "value": str(summary_metrics["working_days"])},
        {"label": "Total Hours", "value": format_duration_readable(summary_metrics["total_minutes"])},
        {"label": "Avg Hours/Day", "value": format_duration_readable(summary_metrics["average_minutes"])},
        {"label": "Missing Punch Days", "value": str(summary_metrics["missing_punch_days"])},
    ]

    extra_kpis = [
        {"label": "First Day", "value": _safe_text(summary_metrics["first_day"], fallback="N/A")},
        {"label": "Last Day", "value": _safe_text(summary_metrics["last_day"], fallback="N/A")},
        {"label": "Total Records", "value": str(summary_metrics["total_records"])},
    ]

    story.append(KpiRow(cards=top_kpis, cols=4, gap=KPI_GAP_X, card_h=KPI_CARD_HEIGHT))
    story.append(Spacer(1, KPI_GAP_Y))
    story.append(KpiRow(cards=extra_kpis, cols=3, gap=KPI_GAP_X, card_h=KPI_CARD_HEIGHT))
    story.append(Spacer(1, KPI_GAP_AFTER))

    table_rows = _table_rows_from_normalized(normalized_rows)
    story.append(
        _build_attendance_table(
            table_rows,
            available_width=available_width,
            total_in_hhmm=total_in_hhmm,
            total_out_hhmm=total_out_hhmm,
        )
    )

    doc.build(
        story,
        onFirstPage=_draw_page_header,
        onLaterPages=_draw_page_header,
        canvasmaker=NumberedCanvas,
    )
    return buffer.getvalue()


def build_daily_pdf(report: dict[str, Any]) -> bytes:
    normalized_rows = [_normalize_daily_row(report)]
    metrics = _derive_summary_metrics(report=report, rows=normalized_rows)
    total_in_hhmm, total_out_hhmm = _resolve_total_in_out_hhmm(report)

    return _build_pdf_document(
        period_label=_safe_text(report.get("date"), fallback="Daily"),
        employee_name=_safe_text(report.get("employee_name"), fallback="Unknown"),
        card_no=_safe_text(report.get("card_no"), fallback="Unknown"),
        normalized_rows=normalized_rows,
        summary_metrics=metrics,
        total_in_hhmm=total_in_hhmm,
        total_out_hhmm=total_out_hhmm,
    )


def build_monthly_pdf(report: dict[str, Any]) -> bytes:
    normalized_rows = _normalize_monthly_rows(report)
    metrics = _derive_summary_metrics(report=report, rows=normalized_rows)
    total_in_hhmm, total_out_hhmm = _resolve_total_in_out_hhmm(report)

    return _build_pdf_document(
        period_label=_safe_text(report.get("month"), fallback="Monthly"),
        employee_name=_safe_text(report.get("employee_name"), fallback="Unknown"),
        card_no=_safe_text(report.get("card_no"), fallback="Unknown"),
        normalized_rows=normalized_rows,
        summary_metrics=metrics,
        total_in_hhmm=total_in_hhmm,
        total_out_hhmm=total_out_hhmm,
    )


def build_yearly_pdf(report: dict[str, Any]) -> bytes:
    normalized_rows = _normalize_yearly_rows(report)
    metrics = _derive_summary_metrics(report=report, rows=normalized_rows)
    total_in_hhmm, total_out_hhmm = _resolve_total_in_out_hhmm(report)

    return _build_pdf_document(
        period_label=_safe_text(report.get("year"), fallback="Yearly"),
        employee_name=_safe_text(report.get("employee_name"), fallback="Unknown"),
        card_no=_safe_text(report.get("card_no"), fallback="Unknown"),
        normalized_rows=normalized_rows,
        summary_metrics=metrics,
        total_in_hhmm=total_in_hhmm,
        total_out_hhmm=total_out_hhmm,
    )
